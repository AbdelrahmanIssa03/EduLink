// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.20.3
// source: user_api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { grpc } from "@improbable-eng/grpc-web";
import { BrowserHeaders } from "browser-headers";

export const protobufPackage = "userAPI";

export interface SignUpRequest {
  username: string;
  email: string;
  password: string;
  role: string;
}

export interface SignUpResponse {
  success: boolean;
  message: string;
  user: User | undefined;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  success: boolean;
  message: string;
  user: User | undefined;
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  success: boolean;
  token: string;
}

export interface ValidateTokenRequest {
  token: string;
}

export interface ValidateTokenResponse {
  valid: boolean;
}

export interface CreateClassRequest {
  userId: string;
  name: string;
  files: string[];
  students: string[];
  startTime: string;
  endTime: string;
}

export interface CreateClassResponse {
  success: boolean;
  errorMessages: string[];
  classroom: Class | undefined;
}

export interface GetClassesRequest {
  userId: string;
}

export interface GetClassesResponse {
  classrooms: Class[];
}

export interface UpdateClassRequest {
  userId: string;
  classroom: Class | undefined;
}

export interface UpdateClassResponse {
  classroom: Class | undefined;
}

export interface DeleteClassRequest {
  userId: string;
  classroomId: string;
}

export interface DeleteClassResponse {
  success: boolean;
  errorMessages: string[];
}

export interface StartSessionRequest {
  userId: string;
  classroomId: string;
  name: string;
}

export interface StartSessionResponse {
  success: boolean;
  errorMessages: string[];
  session: Session | undefined;
}

export interface EndSessionRequest {
  userId: string;
  classroomId: string;
  sessionId: string;
}

export interface EndSessionResponse {
  success: boolean;
  errorMessages: string[];
  session: Session | undefined;
}

export interface User {
  id: string;
  username: string;
  email: string;
  token: string;
  refreshToken: string;
}

export interface Class {
  id: string;
  name: string;
  startTime: string;
  endTime: string;
  files: string[];
  students: string[];
  sessions: Session[];
}

export interface Session {
  id: string;
  title: string;
  date: string;
  isLive: boolean;
}

function createBaseSignUpRequest(): SignUpRequest {
  return { username: "", email: "", password: "", role: "" };
}

export const SignUpRequest: MessageFns<SignUpRequest> = {
  encode(message: SignUpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignUpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignUpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignUpRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: SignUpRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignUpRequest>, I>>(base?: I): SignUpRequest {
    return SignUpRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignUpRequest>, I>>(object: I): SignUpRequest {
    const message = createBaseSignUpRequest();
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseSignUpResponse(): SignUpResponse {
  return { success: false, message: "", user: undefined };
}

export const SignUpResponse: MessageFns<SignUpResponse> = {
  encode(message: SignUpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignUpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignUpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignUpResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: SignUpResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignUpResponse>, I>>(base?: I): SignUpResponse {
    return SignUpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignUpResponse>, I>>(object: I): SignUpResponse {
    const message = createBaseSignUpResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { email: "", password: "" };
}

export const LoginRequest: MessageFns<LoginRequest> = {
  encode(message: LoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { success: false, message: "", user: undefined };
}

export const LoginResponse: MessageFns<LoginResponse> = {
  encode(message: LoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(object: I): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseRefreshTokenResponse(): RefreshTokenResponse {
  return { success: false, token: "" };
}

export const RefreshTokenResponse: MessageFns<RefreshTokenResponse> = {
  encode(message: RefreshTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: RefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(base?: I): RefreshTokenResponse {
    return RefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(object: I): RefreshTokenResponse {
    const message = createBaseRefreshTokenResponse();
    message.success = object.success ?? false;
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseValidateTokenRequest(): ValidateTokenRequest {
  return { token: "" };
}

export const ValidateTokenRequest: MessageFns<ValidateTokenRequest> = {
  encode(message: ValidateTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateTokenRequest {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: ValidateTokenRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateTokenRequest>, I>>(base?: I): ValidateTokenRequest {
    return ValidateTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateTokenRequest>, I>>(object: I): ValidateTokenRequest {
    const message = createBaseValidateTokenRequest();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseValidateTokenResponse(): ValidateTokenResponse {
  return { valid: false };
}

export const ValidateTokenResponse: MessageFns<ValidateTokenResponse> = {
  encode(message: ValidateTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateTokenResponse {
    return { valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false };
  },

  toJSON(message: ValidateTokenResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateTokenResponse>, I>>(base?: I): ValidateTokenResponse {
    return ValidateTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateTokenResponse>, I>>(object: I): ValidateTokenResponse {
    const message = createBaseValidateTokenResponse();
    message.valid = object.valid ?? false;
    return message;
  },
};

function createBaseCreateClassRequest(): CreateClassRequest {
  return { userId: "", name: "", files: [], students: [], startTime: "", endTime: "" };
}

export const CreateClassRequest: MessageFns<CreateClassRequest> = {
  encode(message: CreateClassRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.files) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.students) {
      writer.uint32(34).string(v!);
    }
    if (message.startTime !== "") {
      writer.uint32(42).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(50).string(message.endTime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateClassRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateClassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.files.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.students.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateClassRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => globalThis.String(e)) : [],
      students: globalThis.Array.isArray(object?.students) ? object.students.map((e: any) => globalThis.String(e)) : [],
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "",
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : "",
    };
  },

  toJSON(message: CreateClassRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.files?.length) {
      obj.files = message.files;
    }
    if (message.students?.length) {
      obj.students = message.students;
    }
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateClassRequest>, I>>(base?: I): CreateClassRequest {
    return CreateClassRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateClassRequest>, I>>(object: I): CreateClassRequest {
    const message = createBaseCreateClassRequest();
    message.userId = object.userId ?? "";
    message.name = object.name ?? "";
    message.files = object.files?.map((e) => e) || [];
    message.students = object.students?.map((e) => e) || [];
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    return message;
  },
};

function createBaseCreateClassResponse(): CreateClassResponse {
  return { success: false, errorMessages: [], classroom: undefined };
}

export const CreateClassResponse: MessageFns<CreateClassResponse> = {
  encode(message: CreateClassResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.errorMessages) {
      writer.uint32(18).string(v!);
    }
    if (message.classroom !== undefined) {
      Class.encode(message.classroom, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateClassResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateClassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessages.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.classroom = Class.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateClassResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessages: globalThis.Array.isArray(object?.errorMessages)
        ? object.errorMessages.map((e: any) => globalThis.String(e))
        : [],
      classroom: isSet(object.classroom) ? Class.fromJSON(object.classroom) : undefined,
    };
  },

  toJSON(message: CreateClassResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessages?.length) {
      obj.errorMessages = message.errorMessages;
    }
    if (message.classroom !== undefined) {
      obj.classroom = Class.toJSON(message.classroom);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateClassResponse>, I>>(base?: I): CreateClassResponse {
    return CreateClassResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateClassResponse>, I>>(object: I): CreateClassResponse {
    const message = createBaseCreateClassResponse();
    message.success = object.success ?? false;
    message.errorMessages = object.errorMessages?.map((e) => e) || [];
    message.classroom = (object.classroom !== undefined && object.classroom !== null)
      ? Class.fromPartial(object.classroom)
      : undefined;
    return message;
  },
};

function createBaseGetClassesRequest(): GetClassesRequest {
  return { userId: "" };
}

export const GetClassesRequest: MessageFns<GetClassesRequest> = {
  encode(message: GetClassesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClassesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClassesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClassesRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetClassesRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClassesRequest>, I>>(base?: I): GetClassesRequest {
    return GetClassesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClassesRequest>, I>>(object: I): GetClassesRequest {
    const message = createBaseGetClassesRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseGetClassesResponse(): GetClassesResponse {
  return { classrooms: [] };
}

export const GetClassesResponse: MessageFns<GetClassesResponse> = {
  encode(message: GetClassesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.classrooms) {
      Class.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClassesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClassesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.classrooms.push(Class.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClassesResponse {
    return {
      classrooms: globalThis.Array.isArray(object?.classrooms)
        ? object.classrooms.map((e: any) => Class.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetClassesResponse): unknown {
    const obj: any = {};
    if (message.classrooms?.length) {
      obj.classrooms = message.classrooms.map((e) => Class.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetClassesResponse>, I>>(base?: I): GetClassesResponse {
    return GetClassesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetClassesResponse>, I>>(object: I): GetClassesResponse {
    const message = createBaseGetClassesResponse();
    message.classrooms = object.classrooms?.map((e) => Class.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateClassRequest(): UpdateClassRequest {
  return { userId: "", classroom: undefined };
}

export const UpdateClassRequest: MessageFns<UpdateClassRequest> = {
  encode(message: UpdateClassRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.classroom !== undefined) {
      Class.encode(message.classroom, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateClassRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.classroom = Class.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClassRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      classroom: isSet(object.classroom) ? Class.fromJSON(object.classroom) : undefined,
    };
  },

  toJSON(message: UpdateClassRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.classroom !== undefined) {
      obj.classroom = Class.toJSON(message.classroom);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateClassRequest>, I>>(base?: I): UpdateClassRequest {
    return UpdateClassRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateClassRequest>, I>>(object: I): UpdateClassRequest {
    const message = createBaseUpdateClassRequest();
    message.userId = object.userId ?? "";
    message.classroom = (object.classroom !== undefined && object.classroom !== null)
      ? Class.fromPartial(object.classroom)
      : undefined;
    return message;
  },
};

function createBaseUpdateClassResponse(): UpdateClassResponse {
  return { classroom: undefined };
}

export const UpdateClassResponse: MessageFns<UpdateClassResponse> = {
  encode(message: UpdateClassResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.classroom !== undefined) {
      Class.encode(message.classroom, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateClassResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.classroom = Class.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClassResponse {
    return { classroom: isSet(object.classroom) ? Class.fromJSON(object.classroom) : undefined };
  },

  toJSON(message: UpdateClassResponse): unknown {
    const obj: any = {};
    if (message.classroom !== undefined) {
      obj.classroom = Class.toJSON(message.classroom);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateClassResponse>, I>>(base?: I): UpdateClassResponse {
    return UpdateClassResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateClassResponse>, I>>(object: I): UpdateClassResponse {
    const message = createBaseUpdateClassResponse();
    message.classroom = (object.classroom !== undefined && object.classroom !== null)
      ? Class.fromPartial(object.classroom)
      : undefined;
    return message;
  },
};

function createBaseDeleteClassRequest(): DeleteClassRequest {
  return { userId: "", classroomId: "" };
}

export const DeleteClassRequest: MessageFns<DeleteClassRequest> = {
  encode(message: DeleteClassRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.classroomId !== "") {
      writer.uint32(18).string(message.classroomId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteClassRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClassRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.classroomId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteClassRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      classroomId: isSet(object.classroomId) ? globalThis.String(object.classroomId) : "",
    };
  },

  toJSON(message: DeleteClassRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.classroomId !== "") {
      obj.classroomId = message.classroomId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteClassRequest>, I>>(base?: I): DeleteClassRequest {
    return DeleteClassRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteClassRequest>, I>>(object: I): DeleteClassRequest {
    const message = createBaseDeleteClassRequest();
    message.userId = object.userId ?? "";
    message.classroomId = object.classroomId ?? "";
    return message;
  },
};

function createBaseDeleteClassResponse(): DeleteClassResponse {
  return { success: false, errorMessages: [] };
}

export const DeleteClassResponse: MessageFns<DeleteClassResponse> = {
  encode(message: DeleteClassResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.errorMessages) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteClassResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClassResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessages.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteClassResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessages: globalThis.Array.isArray(object?.errorMessages)
        ? object.errorMessages.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DeleteClassResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessages?.length) {
      obj.errorMessages = message.errorMessages;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteClassResponse>, I>>(base?: I): DeleteClassResponse {
    return DeleteClassResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteClassResponse>, I>>(object: I): DeleteClassResponse {
    const message = createBaseDeleteClassResponse();
    message.success = object.success ?? false;
    message.errorMessages = object.errorMessages?.map((e) => e) || [];
    return message;
  },
};

function createBaseStartSessionRequest(): StartSessionRequest {
  return { userId: "", classroomId: "", name: "" };
}

export const StartSessionRequest: MessageFns<StartSessionRequest> = {
  encode(message: StartSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.classroomId !== "") {
      writer.uint32(18).string(message.classroomId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.classroomId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartSessionRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      classroomId: isSet(object.classroomId) ? globalThis.String(object.classroomId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: StartSessionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.classroomId !== "") {
      obj.classroomId = message.classroomId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartSessionRequest>, I>>(base?: I): StartSessionRequest {
    return StartSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartSessionRequest>, I>>(object: I): StartSessionRequest {
    const message = createBaseStartSessionRequest();
    message.userId = object.userId ?? "";
    message.classroomId = object.classroomId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStartSessionResponse(): StartSessionResponse {
  return { success: false, errorMessages: [], session: undefined };
}

export const StartSessionResponse: MessageFns<StartSessionResponse> = {
  encode(message: StartSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.errorMessages) {
      writer.uint32(18).string(v!);
    }
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessages.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartSessionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessages: globalThis.Array.isArray(object?.errorMessages)
        ? object.errorMessages.map((e: any) => globalThis.String(e))
        : [],
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
    };
  },

  toJSON(message: StartSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessages?.length) {
      obj.errorMessages = message.errorMessages;
    }
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartSessionResponse>, I>>(base?: I): StartSessionResponse {
    return StartSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartSessionResponse>, I>>(object: I): StartSessionResponse {
    const message = createBaseStartSessionResponse();
    message.success = object.success ?? false;
    message.errorMessages = object.errorMessages?.map((e) => e) || [];
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseEndSessionRequest(): EndSessionRequest {
  return { userId: "", classroomId: "", sessionId: "" };
}

export const EndSessionRequest: MessageFns<EndSessionRequest> = {
  encode(message: EndSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.classroomId !== "") {
      writer.uint32(18).string(message.classroomId);
    }
    if (message.sessionId !== "") {
      writer.uint32(26).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.classroomId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndSessionRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      classroomId: isSet(object.classroomId) ? globalThis.String(object.classroomId) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
    };
  },

  toJSON(message: EndSessionRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.classroomId !== "") {
      obj.classroomId = message.classroomId;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndSessionRequest>, I>>(base?: I): EndSessionRequest {
    return EndSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndSessionRequest>, I>>(object: I): EndSessionRequest {
    const message = createBaseEndSessionRequest();
    message.userId = object.userId ?? "";
    message.classroomId = object.classroomId ?? "";
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseEndSessionResponse(): EndSessionResponse {
  return { success: false, errorMessages: [], session: undefined };
}

export const EndSessionResponse: MessageFns<EndSessionResponse> = {
  encode(message: EndSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.errorMessages) {
      writer.uint32(18).string(v!);
    }
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessages.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndSessionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessages: globalThis.Array.isArray(object?.errorMessages)
        ? object.errorMessages.map((e: any) => globalThis.String(e))
        : [],
      session: isSet(object.session) ? Session.fromJSON(object.session) : undefined,
    };
  },

  toJSON(message: EndSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessages?.length) {
      obj.errorMessages = message.errorMessages;
    }
    if (message.session !== undefined) {
      obj.session = Session.toJSON(message.session);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EndSessionResponse>, I>>(base?: I): EndSessionResponse {
    return EndSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EndSessionResponse>, I>>(object: I): EndSessionResponse {
    const message = createBaseEndSessionResponse();
    message.success = object.success ?? false;
    message.errorMessages = object.errorMessages?.map((e) => e) || [];
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseUser(): User {
  return { id: "", username: "", email: "", token: "", refreshToken: "" };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.token !== "") {
      writer.uint32(34).string(message.token);
    }
    if (message.refreshToken !== "") {
      writer.uint32(42).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.token = object.token ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseClass(): Class {
  return { id: "", name: "", startTime: "", endTime: "", files: [], students: [], sessions: [] };
}

export const Class: MessageFns<Class> = {
  encode(message: Class, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.startTime !== "") {
      writer.uint32(26).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(34).string(message.endTime);
    }
    for (const v of message.files) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.students) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.sessions) {
      Session.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Class {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.files.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.students.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.sessions.push(Session.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Class {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "",
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : "",
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => globalThis.String(e)) : [],
      students: globalThis.Array.isArray(object?.students) ? object.students.map((e: any) => globalThis.String(e)) : [],
      sessions: globalThis.Array.isArray(object?.sessions) ? object.sessions.map((e: any) => Session.fromJSON(e)) : [],
    };
  },

  toJSON(message: Class): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.files?.length) {
      obj.files = message.files;
    }
    if (message.students?.length) {
      obj.students = message.students;
    }
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => Session.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Class>, I>>(base?: I): Class {
    return Class.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Class>, I>>(object: I): Class {
    const message = createBaseClass();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.files = object.files?.map((e) => e) || [];
    message.students = object.students?.map((e) => e) || [];
    message.sessions = object.sessions?.map((e) => Session.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSession(): Session {
  return { id: "", title: "", date: "", isLive: false };
}

export const Session: MessageFns<Session> = {
  encode(message: Session, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.date !== "") {
      writer.uint32(26).string(message.date);
    }
    if (message.isLive !== false) {
      writer.uint32(32).bool(message.isLive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Session {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isLive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Session {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      date: isSet(object.date) ? globalThis.String(object.date) : "",
      isLive: isSet(object.isLive) ? globalThis.Boolean(object.isLive) : false,
    };
  },

  toJSON(message: Session): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.date !== "") {
      obj.date = message.date;
    }
    if (message.isLive !== false) {
      obj.isLive = message.isLive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Session>, I>>(base?: I): Session {
    return Session.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Session>, I>>(object: I): Session {
    const message = createBaseSession();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.date = object.date ?? "";
    message.isLive = object.isLive ?? false;
    return message;
  },
};

export interface Authentication {
  SignUp(request: DeepPartial<SignUpRequest>, metadata?: grpc.Metadata): Promise<SignUpResponse>;
  Login(request: DeepPartial<LoginRequest>, metadata?: grpc.Metadata): Promise<LoginResponse>;
  RefreshToken(request: DeepPartial<RefreshTokenRequest>, metadata?: grpc.Metadata): Promise<RefreshTokenResponse>;
  ValidateToken(request: DeepPartial<ValidateTokenRequest>, metadata?: grpc.Metadata): Promise<ValidateTokenResponse>;
}

export class AuthenticationClientImpl implements Authentication {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.SignUp = this.SignUp.bind(this);
    this.Login = this.Login.bind(this);
    this.RefreshToken = this.RefreshToken.bind(this);
    this.ValidateToken = this.ValidateToken.bind(this);
  }

  SignUp(request: DeepPartial<SignUpRequest>, metadata?: grpc.Metadata): Promise<SignUpResponse> {
    return this.rpc.unary(AuthenticationSignUpDesc, SignUpRequest.fromPartial(request), metadata);
  }

  Login(request: DeepPartial<LoginRequest>, metadata?: grpc.Metadata): Promise<LoginResponse> {
    return this.rpc.unary(AuthenticationLoginDesc, LoginRequest.fromPartial(request), metadata);
  }

  RefreshToken(request: DeepPartial<RefreshTokenRequest>, metadata?: grpc.Metadata): Promise<RefreshTokenResponse> {
    return this.rpc.unary(AuthenticationRefreshTokenDesc, RefreshTokenRequest.fromPartial(request), metadata);
  }

  ValidateToken(request: DeepPartial<ValidateTokenRequest>, metadata?: grpc.Metadata): Promise<ValidateTokenResponse> {
    return this.rpc.unary(AuthenticationValidateTokenDesc, ValidateTokenRequest.fromPartial(request), metadata);
  }
}

export const AuthenticationDesc = { serviceName: "userAPI.Authentication" };

export const AuthenticationSignUpDesc: UnaryMethodDefinitionish = {
  methodName: "SignUp",
  service: AuthenticationDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SignUpRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = SignUpResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AuthenticationLoginDesc: UnaryMethodDefinitionish = {
  methodName: "Login",
  service: AuthenticationDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return LoginRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = LoginResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AuthenticationRefreshTokenDesc: UnaryMethodDefinitionish = {
  methodName: "RefreshToken",
  service: AuthenticationDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return RefreshTokenRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = RefreshTokenResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const AuthenticationValidateTokenDesc: UnaryMethodDefinitionish = {
  methodName: "ValidateToken",
  service: AuthenticationDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ValidateTokenRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = ValidateTokenResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface ClassManager {
  CreateClass(request: DeepPartial<CreateClassRequest>, metadata?: grpc.Metadata): Promise<CreateClassResponse>;
  GetClasses(request: DeepPartial<GetClassesRequest>, metadata?: grpc.Metadata): Promise<GetClassesResponse>;
  UpdateClass(request: DeepPartial<UpdateClassRequest>, metadata?: grpc.Metadata): Promise<UpdateClassResponse>;
  DeleteClass(request: DeepPartial<DeleteClassRequest>, metadata?: grpc.Metadata): Promise<DeleteClassResponse>;
}

export class ClassManagerClientImpl implements ClassManager {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.CreateClass = this.CreateClass.bind(this);
    this.GetClasses = this.GetClasses.bind(this);
    this.UpdateClass = this.UpdateClass.bind(this);
    this.DeleteClass = this.DeleteClass.bind(this);
  }

  CreateClass(request: DeepPartial<CreateClassRequest>, metadata?: grpc.Metadata): Promise<CreateClassResponse> {
    return this.rpc.unary(ClassManagerCreateClassDesc, CreateClassRequest.fromPartial(request), metadata);
  }

  GetClasses(request: DeepPartial<GetClassesRequest>, metadata?: grpc.Metadata): Promise<GetClassesResponse> {
    return this.rpc.unary(ClassManagerGetClassesDesc, GetClassesRequest.fromPartial(request), metadata);
  }

  UpdateClass(request: DeepPartial<UpdateClassRequest>, metadata?: grpc.Metadata): Promise<UpdateClassResponse> {
    return this.rpc.unary(ClassManagerUpdateClassDesc, UpdateClassRequest.fromPartial(request), metadata);
  }

  DeleteClass(request: DeepPartial<DeleteClassRequest>, metadata?: grpc.Metadata): Promise<DeleteClassResponse> {
    return this.rpc.unary(ClassManagerDeleteClassDesc, DeleteClassRequest.fromPartial(request), metadata);
  }
}

export const ClassManagerDesc = { serviceName: "userAPI.ClassManager" };

export const ClassManagerCreateClassDesc: UnaryMethodDefinitionish = {
  methodName: "CreateClass",
  service: ClassManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return CreateClassRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = CreateClassResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ClassManagerGetClassesDesc: UnaryMethodDefinitionish = {
  methodName: "GetClasses",
  service: ClassManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetClassesRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = GetClassesResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ClassManagerUpdateClassDesc: UnaryMethodDefinitionish = {
  methodName: "UpdateClass",
  service: ClassManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UpdateClassRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = UpdateClassResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const ClassManagerDeleteClassDesc: UnaryMethodDefinitionish = {
  methodName: "DeleteClass",
  service: ClassManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return DeleteClassRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = DeleteClassResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export interface SessionManager {
  StartSession(request: DeepPartial<StartSessionRequest>, metadata?: grpc.Metadata): Promise<StartSessionResponse>;
  EndSession(request: DeepPartial<EndSessionRequest>, metadata?: grpc.Metadata): Promise<EndSessionResponse>;
}

export class SessionManagerClientImpl implements SessionManager {
  private readonly rpc: Rpc;

  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.StartSession = this.StartSession.bind(this);
    this.EndSession = this.EndSession.bind(this);
  }

  StartSession(request: DeepPartial<StartSessionRequest>, metadata?: grpc.Metadata): Promise<StartSessionResponse> {
    return this.rpc.unary(SessionManagerStartSessionDesc, StartSessionRequest.fromPartial(request), metadata);
  }

  EndSession(request: DeepPartial<EndSessionRequest>, metadata?: grpc.Metadata): Promise<EndSessionResponse> {
    return this.rpc.unary(SessionManagerEndSessionDesc, EndSessionRequest.fromPartial(request), metadata);
  }
}

export const SessionManagerDesc = { serviceName: "userAPI.SessionManager" };

export const SessionManagerStartSessionDesc: UnaryMethodDefinitionish = {
  methodName: "StartSession",
  service: SessionManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return StartSessionRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = StartSessionResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

export const SessionManagerEndSessionDesc: UnaryMethodDefinitionish = {
  methodName: "EndSession",
  service: SessionManagerDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return EndSessionRequest.encode(this).finish();
    },
  } as any,
  responseType: {
    deserializeBinary(data: Uint8Array) {
      const value = EndSessionResponse.decode(data);
      return {
        ...value,
        toObject() {
          return value;
        },
      };
    },
  } as any,
};

interface UnaryMethodDefinitionishR extends grpc.UnaryMethodDefinition<any, any> {
  requestStream: any;
  responseStream: any;
}

type UnaryMethodDefinitionish = UnaryMethodDefinitionishR;

interface Rpc {
  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any>;
}

export class GrpcWebImpl {
  private host: string;
  private options: {
    transport?: grpc.TransportFactory;

    debug?: boolean;
    metadata?: grpc.Metadata;
    upStreamRetryCodes?: number[];
  };

  constructor(
    host: string,
    options: {
      transport?: grpc.TransportFactory;

      debug?: boolean;
      metadata?: grpc.Metadata;
      upStreamRetryCodes?: number[];
    },
  ) {
    this.host = host;
    this.options = options;
  }

  unary<T extends UnaryMethodDefinitionish>(
    methodDesc: T,
    _request: any,
    metadata: grpc.Metadata | undefined,
  ): Promise<any> {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata
      ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
      : metadata ?? this.options.metadata;
    return new Promise((resolve, reject) => {
      grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata ?? {},
        ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
        debug: this.options.debug ?? false,
        onEnd: function (response) {
          if (response.status === grpc.Code.OK) {
            resolve(response.message!.toObject());
          } else {
            const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
            reject(err);
          }
        },
      });
    });
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export class GrpcWebError extends globalThis.Error {
  constructor(message: string, public code: grpc.Code, public metadata: grpc.Metadata) {
    super(message);
  }
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
